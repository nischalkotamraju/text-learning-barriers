/**
 * AI API client using OpenAI for both text analysis and image generation
 * - Text Analysis: OpenAI GPT-3.5-turbo
 * - Image Generation: OpenAI DALL-E 3
 */

/**
 * Analyze text using OpenAI API
 * @param inputText The text to analyze
 * @param format The desired format (comic, flowchart, infographic)
 * @returns Promise resolving to structured content
 */
export const analyzeTextWithOpenAI = async (
  inputText: string, 
  format: 'comic' | 'flowchart' | 'infographic'
): Promise<any> => {
  try {
    const openaiApiKey = import.meta.env.VITE_OPENAI_API_KEY;
    if (!openaiApiKey) {
      throw new Error('OpenAI API key not found. Please add VITE_OPENAI_API_KEY to your .env file');
    }

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${openaiApiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `You are an AI that helps convert text into visual learning formats for neurodiverse students. Based on the input text and selected format (${format}), provide a structured breakdown that can be used to create visual content. Return a JSON response with: title, description, and sections array containing the visual elements.`
          },
          {
            role: 'user',
            content: `Convert this text into a ${format} format: "${inputText}"`
          }
        ],
        max_tokens: 1000,
        temperature: 0.7
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenAI API Error Response:', errorText);
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
    console.log('OpenAI API Response:', data);
    const aiResponse = data.choices[0]?.message?.content;
    
    if (!aiResponse) {
      console.error('No response from OpenAI API:', data);
      throw new Error('No content generated by OpenAI API');
    }

    // Clean and parse the JSON response
    let cleanedText = aiResponse;
    
    // Remove markdown code blocks if present
    cleanedText = cleanedText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    
    // Try to parse as JSON, fallback to structured object if parsing fails
    try {
      const parsed = JSON.parse(cleanedText);
      return parsed;
    } catch (error) {
      console.log('JSON parsing failed, creating structured fallback:', error);
      console.log('Original text:', aiResponse.substring(0, 200));
      
      // Extract title if it exists in the text
      const titleMatch = aiResponse.match(/"title":\s*"([^"]+)"/);
      const title = titleMatch ? titleMatch[1] : `${format.charAt(0).toUpperCase() + format.slice(1)} - ${new Date().toLocaleDateString()}`;
      
      return {
        title: title,
        description: aiResponse,
        sections: []
      };
    }
  } catch (error) {
    console.error('Error analyzing text with OpenAI:', error);
    throw error;
  }
};

/**
 * Generate image using OpenAI DALL-E 3
 * @param prompt The text prompt for image generation
 * @param format The desired format (comic, flowchart, infographic)
 * @returns Promise resolving to multiple image variations
 */
export const generateImageWithDALLE = async (
  prompt: string,
  format: 'comic' | 'flowchart' | 'infographic'
): Promise<{ variations: Array<{id: number, url: string, seed: number}>, message: string }> => {
  try {
    console.log('Generating multiple images with OpenAI DALL-E 3...');
    
    const openaiApiKey = import.meta.env.VITE_OPENAI_API_KEY;
    if (!openaiApiKey) {
      throw new Error('OpenAI API key not found. Please add VITE_OPENAI_API_KEY to your .env file');
    }

    // Create format-specific prompts that are very explicit about content, not photos
    const formatPrompts = {
      comic: `Create a digital comic strip illustration about: ${prompt}. 
        REQUIREMENTS: 
        - Multiple comic panels with clear borders
        - Characters speaking in speech bubbles with LARGE, BOLD, BLACK text
        - Cartoon/anime art style, NOT a photograph
        - Bright, contrasting colors for readability
        - Educational content shown through character dialogue and actions
        - Text must be extremely clear and readable for learning purposes
        AVOID: Real photographs, blurry text, decorative fonts`,

      flowchart: `Create a digital flowchart diagram about: ${prompt}.
        REQUIREMENTS:
        - Clean geometric boxes connected by arrows
        - LARGE, BOLD, BLACK text inside each box
        - High contrast colors (white boxes, black text, colored arrows)
        - Professional diagram style, NOT a photograph of a whiteboard
        - Clear logical flow from start to finish
        - Text must be extremely readable for educational purposes
        AVOID: Hand-drawn appearance, photographs, small text, decorative elements`,

      infographic: `Create a digital infographic layout about: ${prompt}.
        REQUIREMENTS:
        - Modern flat design with clear sections
        - LARGE, BOLD headings and bullet points
        - High contrast text (black on white/light backgrounds)
        - Icons and visual elements that support the information
        - Clean, organized layout with plenty of white space
        - NOT a photograph of a poster or physical infographic
        - Text must be extremely clear and readable for learning
        AVOID: Real world photos, handwritten text, cluttered layouts, small fonts`
    };

    const enhancedPrompt = formatPrompts[format];
    
    // Generate exactly 3 variations with retry logic
    const variations = [];
    const maxRetries = 2; // Retry failed generations
    
    for (let i = 0; i < 3; i++) {
      let variationGenerated = false;
      let retryCount = 0;
      
      while (!variationGenerated && retryCount <= maxRetries) {
        try {
          console.log(`Generating variation ${i + 1}/3${retryCount > 0 ? ` (retry ${retryCount})` : ''}...`);
          
          // Add slight variation to the prompt for each attempt to get different results
          const promptVariation = retryCount === 0 ? enhancedPrompt : 
            `${enhancedPrompt} Style variation ${i + 1}: ${retryCount === 1 ? 'slightly different layout and colors' : 'alternative visual approach'}`;
          
          const response = await fetch('https://api.openai.com/v1/images/generations', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${openaiApiKey}`
            },
            body: JSON.stringify({
              model: 'dall-e-3',
              prompt: promptVariation,
              n: 1,
              size: '1024x1024',
              quality: 'standard',
              style: 'natural'
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error(`DALL-E API Error for variation ${i + 1} (attempt ${retryCount + 1}):`, errorText);
            retryCount++;
            
            if (retryCount <= maxRetries) {
              console.log(`Retrying variation ${i + 1} in 2 seconds...`);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
            continue;
          }

          const data = await response.json();
          
          if (data.data && data.data[0] && data.data[0].url) {
            variations.push({
              id: i + 1,
              url: data.data[0].url,
              seed: Math.floor(Math.random() * 1000000) + i * 12345
            });
            console.log(`✅ Generated variation ${i + 1} successfully`);
            variationGenerated = true;
          } else {
            console.error(`No image data returned for variation ${i + 1}`);
            retryCount++;
          }
          
        } catch (error) {
          console.error(`Error generating variation ${i + 1} (attempt ${retryCount + 1}):`, error);
          retryCount++;
          
          if (retryCount <= maxRetries) {
            console.log(`Retrying variation ${i + 1} in 2 seconds...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
      }
      
      // If we couldn't generate this variation after retries, add a placeholder
      if (!variationGenerated) {
        console.warn(`⚠️ Could not generate variation ${i + 1} after ${maxRetries + 1} attempts, using placeholder`);
        const placeholderImages = {
          comic: 'https://via.placeholder.com/1024x1024/4F46E5/FFFFFF?text=Comic+Placeholder',
          flowchart: 'https://via.placeholder.com/1024x1024/10B981/FFFFFF?text=Flowchart+Placeholder', 
          infographic: 'https://via.placeholder.com/1024x1024/F59E0B/FFFFFF?text=Infographic+Placeholder'
        };
        
        variations.push({
          id: i + 1,
          url: placeholderImages[format],
          seed: Math.floor(Math.random() * 1000000) + i * 12345
        });
      }
      
      // Add delay between variations to avoid rate limiting
      if (i < 2) {
        await new Promise(resolve => setTimeout(resolve, 1500));
      }
    }

    // Ensure we always have exactly 3 variations
    while (variations.length < 3) {
      const placeholderImages = {
        comic: 'https://via.placeholder.com/1024x1024/4F46E5/FFFFFF?text=Comic+Placeholder',
        flowchart: 'https://via.placeholder.com/1024x1024/10B981/FFFFFF?text=Flowchart+Placeholder', 
        infographic: 'https://via.placeholder.com/1024x1024/F59E0B/FFFFFF?text=Infographic+Placeholder'
      };
      
      variations.push({
        id: variations.length + 1,
        url: placeholderImages[format],
        seed: Math.floor(Math.random() * 1000000) + variations.length * 12345
      });
    }

    const successfulGenerations = variations.filter(v => !v.url.includes('placeholder')).length;
    console.log(`✅ Generated ${successfulGenerations} DALL-E images + ${variations.length - successfulGenerations} placeholders = ${variations.length} total variations`);

    return {
      variations,
      message: `Generated ${variations.length} ${format} variations with extra clear text. Choose the one with the clearest, most readable content for your learners.`
    };
    
  } catch (error) {
    console.error('Error generating images with DALL-E:', error);
    throw error;
  }
};

/**
 * Generate placeholder image when DALL-E fails
 * @param prompt The original prompt
 * @param format The desired format
 * @returns Promise resolving to placeholder image variations
 */
export const generateImagePlaceholder = async (
  prompt: string,
  format: 'comic' | 'flowchart' | 'infographic'
): Promise<{ variations: Array<{id: number, url: string, seed: number}>, message: string }> => {
  console.log('Using placeholder image generation');
  console.log('Image generation prompt:', prompt);
  console.log('Format:', format);
  
  // Enhanced placeholder images with better styling
  const placeholderImages = {
    comic: 'https://via.placeholder.com/1024x1024/4F46E5/FFFFFF?text=Comic+Strip+Placeholder',
    flowchart: 'https://via.placeholder.com/1024x1024/10B981/FFFFFF?text=Flowchart+Placeholder', 
    infographic: 'https://via.placeholder.com/1024x1024/F59E0B/FFFFFF?text=Infographic+Placeholder'
  };
  
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  return {
    variations: [
      { 
        id: 1, 
        url: placeholderImages[format], 
        seed: 123456
      },
      { 
        id: 2, 
        url: placeholderImages[format], 
        seed: 234567
      },
      { 
        id: 3, 
        url: placeholderImages[format], 
        seed: 345678
      }
    ],
    message: 'Placeholder images generated (DALL-E API unavailable)'
  };
};
